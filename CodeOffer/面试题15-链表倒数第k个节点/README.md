[TOC]

# 题目

**内容**：输入一个链表，输出该链表倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始它们的值依次是1/2/3/4/5/6，这个链表的倒数第3个节点是值为4的节点。

链表节点定义如下：

``` c++
struct ListNode {
  	int m_nValue;
  	ListNode *m_pNext;
};
```

# 思路

## 解法一

遍历链表2次，第一次统计出链表中节点的个数，第二次移动n - k + 1步就可以找到倒数第k个节点。

## 解法二

遍历链表1次。定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾节点时，第二个指针（走在后面的）正好是倒数第k个节点。

鲁棒性考虑：

* 输入的链表为空指针。
* 输入的链表总节点数少于k。
* 输入的k为0。

综合考虑，代码如下：

```c++
ListNode* FindKthToTail(ListNode *pListHead, int k) {
	if (pListHead == NULL || k <= 0)
		return NULL;

	ListNode *front = pListHead;
	ListNode *back = pListHead;

	int i = 1;
	while (i < k && front->m_pNext) {
		front = front->m_pNext;
		i++;
	} // 跳出循环的两个条件：i == k 或者 front->m_pNext == NULL.

	// 由于front->m_pNext导致的
	if (i < k)
		return NULL;

	while(front->m_pNext) {
		front = front->m_pNext;
		back = back->m_pNext;
	}

	return back;
}
```

# 测试用例

* 功能测试（第k个节点在链表的中间，第k个节点是链表的头节点，第k个节点是链表的尾节点）。
* 特殊输入测试（链表头节点为NULL，链表的节点总数少于k，k等于0）。

# 扩展

**题目一**：求链表的中间节点。如果链表中节点总数为奇数，返回中间节点；如果节点总数为偶数，返回中间两个节点的任意一个。

**思路**：两个指针，一个指针一次走一步，一个指针一次走两步。当走得快的指针走到链表末尾时，走得慢的指针正好在链表的中间。

**题目二**：判断一个单向链表是否形成了环形结构。

**思路**：两个指针，一个指针一次走一步，一个指针一次走两步。当走得快的指针追上了走得慢的指针，那么链表就是环形链表；如果走得快的指针走到了链表的末尾（m_pNext指向NULL）都没有追上走得慢的指针，那么链表就不是环形链表。

**另**：统计每个节点记录自己被遍历的次数，如果某节点被遍历两次，则说明该链表是环形链表。

从某种程度上来说，第一种方法空间复杂度较低，时间复杂度比第二种方法较高。

# 举一反三

当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。快慢指针。