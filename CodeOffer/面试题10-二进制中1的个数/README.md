[TOC]

# 题目

**内容**：请实现一个函数，输入一个整数，输出该二进制表示中1的个数。例如，把9表示成二进制是1001，有两位为1。因此，如果输入9，该函数输出2。

# 思路

## 解法一：可能引起死循环的解法

**基本思路**：先判断整数二进制表示中最右边一位是不是1。接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断是不是1。这样每次移动一位，直到整个整数变为0为止。

**详细代码**：

```c++
int NumberOfOne(int n) {
	int count = 0;
	while (n) {
		if (n & 1)
			count++;

		n = n >> 1;
	}

	return count;
}
```

问题：

* 可以把右移运算换成除以2吗？

不能，除法效率比移位运算效率低得多。

* 输入负数会发生什么？

死循环。正数右移时，高位补0；负数右移时，高位补1。因此，负数右移后补1，导致最终数字变为0xFFFFFFFF而陷入死循环。

## 解法二：常规解法

**基本思路**：为了避免死循环，我们可以不右移输入的数字n。首先，把n和1做与运算，判断n的最低位是不是1。接着把1左移一位得到2，再和n做与运算，就能判断n的次低位是不是1......这样反复左移，每次都能判断n其中一位是不是1。

**详细代码**：

``` c++
int NumberOfOne2(int n) {
	int count = 0;
	unsigned int flag = 1;
	while (flag) {
		if (n & flag)
			count++;

		flag = flag << 1;
	}

	return count;
}
```

这个解法中循环的次数等于整数二进制的位数，32位的整数需要循环32次。

## 解法三：能给面试官带来惊喜的解法

**基本思路**：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。

**详细代码**：

``` c++
int NumberOfOne3(int n) {
	int count = 0;
	while (n) {
		count++;
		n = (n - 1) & n;
	}

	return count;
}
```

# 测试用例

* 正数（包括边界值1，0x7FFFFFFF）；
* 负数（包括边界值0x80000000，0xFFFFFFF）;
* 0。

# 举一反三

**把一个整数减去1之后再和原来的整数做位于运算，得到的结果相当于是把整数的二进制表示中的最右边一个1变成0。很多二进制的问题都可以用这个思路解决**。

# 扩展

**题目一**：用一条语句判断一个整数是不是2的整数次方。

**思路**：运用前面的举一反三，判断`(n-1)&n`是否为0。不为0，则不是；为0，则是。因为该方法将n的最右边的1变为了0，如果不是2的整数次方，则说明二进制表示不只一个1。 

**题目二**：输入两个整数m和n，计算需要改变m的二进制表示中的多少位才能得到n。

**思路**：第一步求这两个数的异或，第二步统计异或结果中1的位数。